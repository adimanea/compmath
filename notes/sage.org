#+TITLE: SageMath Notes
#+AUTHOR: Adrian

This document contains notes that help me learn to use Sage in my workflow.
As such, it will be centered on my tools and approach and a more 
"general audience" will follow.

My setup is:
- OS: Manjaro i3;
- Computing Environment: Emacs 26.3;
- Web browser: Firefox 77.

* Installation and First Run
We need to install both Sage as a program and its Jupyter kernel if we are
to use it as such. I will not be using virtual environments, but that is
possible. So:
#+BEGIN_SRC sh
  $ sudo pacman -S sagemath sagemath-jupyter
#+END_SRC

Beforehand or afterwards, one may look at the related packages with:
#+BEGIN_SRC sh
  $ pacman -Ss sagemath
#+END_SRC

Perhaps relevant could be:
- =sagetex=, which will allow one to integrate Sage computations into
  (La)TeX documents;
- =sagemath-doc=, which contain a local HTML copy of the documentation.

After installation, it could be run either in the terminal by simply typing
=sage=:
#+BEGIN_SRC sh
  $ sage
#+END_SRC
which will start with:
#+BEGIN_SRC sh
	┌────────────────────────────────────────────────────────────────────┐
	│ SageMath version 9.1, Release Date: 2020-05-20                     │
	│ Using Python 3.8.3. Type "help()" for help.                        │
	└────────────────────────────────────────────────────────────────────┘
	sage:  
#+END_SRC
or if you choose to run it inside a Jupyter notebook, =cd= to the directory
where the server will be started and where you choose to store the notebooks.
Then enter:
#+BEGIN_SRC sh
  $ sage -n jupyter
#+END_SRC
This will start the server and one can choose to create a new notebook, with
the appropriate Sage kernel.

If only the Python kernel is available, make sure you have installed also the
=sagemath-jupyter= package as well.

Interactive computations can be performed, in plain text mode in the terminal,
by pressing =Enter= after each step or inside Jupyter notebook cells, which
are evaluated by pressing =Shift + Enter= after each command.

Should a command require GUI capabilities that the terminal is not capable of,
such as plots, the terminal interface will open the result in the default
web browser.

For example:
#+BEGIN_SRC sh
  sage: u(n) = n^100 / 100^n
  sage: plot(u(x), x, 1 40)
#+END_SRC
will show the plot in the notebook if run inside Jupyter or in a web browser,
if run from the terminal.

The Jupyter server can be killed with =C-c C-c=, but /make sure to save the/
/notebook beforehand/. Otherwise, subsequent operations on the notebook will
be available once the server is restarted.

By entering =%display latex= in any Jupyter cell, all subsequent outputs
will be formatted using MathJax.

What will follow is an overview of the Sage syntax and examples that will later
be put together in a more focused way in order to be used in my classes.

* Numerical Computation
Simple computations can be inserted readily, using the Python syntax:
#+BEGIN_SRC sh
  sage: 2^3
  8
  sage: 3**3
  27
  sage: 20/14
  10/7
  sage: 20.0 / 14
  1.42857142457143
  sage: numerical_approx(20/14)
  1.42857142457143
  sage: numerical_approx(20/14, digits=3)
  1.429
  sage: 20 // 6		# quotient
  3
  sage: 20 % 6		# remainder
  2
  sage: arctan(1)
  1/4*pi
  sage: exp(2 * I * pi)
  1
#+END_SRC

Help and examples for each function can be called by adding =?= after the
function name, e.g. =sin?=.

* More Syntax and Symbolic Variables
To save a computation, it must be assigned to a variable:
#+BEGIN_SRC sh
  sage: y = 1 + 2
  sage: y
  3
#+END_SRC

Chaining instructions is done with =;=:
#+BEGIN_SRC sh
  sage: y = 3 ; x = y + 2 ; x
  5
#+END_SRC

The previous results are saved in the special variables =_, __, ___=.

In case one redefines some predefined variables or functions, such as
=pi=, they can be restored with =restore()=. The function =reset()= does
even more, by clearing all the user-defined variables as well.

*Symbolic variables* can be declared using the class =SR= (from Symbolic Ring),
with the method =SR.var()=, which is also available in shorthand with =var()=.
Only =x= is reserved and predefined as symbolic variable, any others should
be declared explicitly.
#+BEGIN_SRC sh
  sage: z = SR.var('z')
  sage: 2*z + 3
  2*z + 3
  sage: y = var('z')
  sage: 2*y + 3
  2*z + 3
#+END_SRC

There is also a shortcut for defining a *sequence of symbolic variables*:
#+BEGIN_SRC sh
  sage: x = var('x', 100)			# declares x0, x1, ..., x99
  sage: (x[0] + x[1])*x[99]
  (x0 + x1)*x99
#+END_SRC

/In Jupyter notebooks only/, it is possible to use =automatic_names(True)=,
which creates a symbolic variable automatically whenever a new name is used.

* Analysis and Algebra
** Expansions, Substitutions and Simplification
In symbolic computations, one can make explicit substitutions
with the =subs()= method for variables or the =substitute()=
method for functions. Note the double equal sign for the latter:
#+BEGIN_SRC sage
  sage: a, x = var('a, x'); y = cos(x + a) * (x + 1); y
  (x + 1)*cos(a + x)
  sage: y.subs(a = -x); y.subs(x = pi/2, a=pi/3); y.subs(x = 0.5, a=2.3)
  x + 1
  -1/4*sqrt(3)*(pi + 2)
  -1.41333351100299
  sage: y, z = var('y, z'); f = x^3 + y^2 + z
  sage: f.substitute(x^3 == y^2, z == 1)
  2*y^2 + 1
#+END_SRC

Functions can be expanded with the =expand()= method and symbolic expressions
can be turned into functions with the =function()= method:
#+BEGIN_SRC sage
  sage: f(x) = (2*x + 1)^3; f(-3)
  -125
  sage: f.expand()
  x |--> 8*x^3 + 12*x^2 + 6*x + 1

  sage: y = var('y'); u = sin(x) + x*cos(y)
  sage: v = u.function(x, y); v
  (x, y) |--> x*cos(y) + sin(x)
  sage: w(x, y) = u; w
  (x, y) |--> x*cos(y) + sin(x)
#+END_SRC

Further, expressions can be factored, grouping the terms according to the
powers of a specified variable, with the =collect()= method:
#+BEGIN_SRC sage
  sage: p = (x + y) * (x + 1)^2
  sage: p2 = p.expand(); p2
  x^3 + x^2*y + 2*x^2 + 2*x*y + x + y
  sage: p2.collect(y)
  x^3 + x^2*(y + 2) + x*(2*y + 1) + y
#+END_SRC

For rational functions, there are also the methods:
- =combine()=, which computes the fractions that have a common denominator;
- =partial_fraction()=, which decomposes in partial fractions.
#+BEGIN_SRC sage
  sage: fraction = b/a + c/a + d/n
  sage: fraction.combine()
  (b + c)/a + d/n

  sage: fraction = 1/((x^3 + 1)*y^2)
  sage: fraction.partial_fraction(x)
  (-(x-2))/(3*(x^2 - x + 1)*y^2) + 1/(3*(x + 1)*y^2)
#+END_SRC

** Assumptions
Computations can be made under certain assumptions, which if not explicitly
discarded, are kept throughout the computation:
#+BEGIN_SRC sage
  sage: assume(x > 0); bool(sqrt(x^2) == x)
  True
  sage: forget(x > 0); bool(sqrt(x^2) == x)
  False
  sage: n = var('n'); assume(n, 'integer'); sin(n*pi)
  0
#+END_SRC

** Solving Equations
| Syntax                      | What it solves/returns          |
|-----------------------------+---------------------------------|
| =solve=                     | symbolic solution for equations |
| =roots=                     | roots with multiplicities       |
| =find_root=                 | numerical solving               |
| =solve_right=, =solve_left= | linear equations                |
| =desolve=                   | differential equations          |
| =rsolve=                    | recurrence equations            |
Some of these can take more arguments. For example, try the following
(output is omitted):
#+BEGIN_SRC sage
  sage: z, phi = var('z, phi')
  sage: eq = z**2 - 2/cos(phi)*z + 5/cos(phi)**2 - 4 == 0; eq
  sage: eq.lhs()                  # extracts left hand side
  sage: solve(eq, z)              # solve for z
  sage: solve(eq, z, solution_dict=True)  # return solutions as dictionary
  sage: solve([x + y == 3, 2*x + 2*y == 6], x, y) # system of eqs
  sage: solve(x^2 + x - 1 > 0, x)         # inequality
  sage: find_root(eq, 0.1, pi)            # search in [0.1, pi]
  sage: (x^3 + 2*x + 1).roots(x)          # return roots
  sage: (x^3 + 2*x + 1).roots(x, ring=RR) # return REAL roots only
  sage: y = function('y')(x)              # y = y(x)

  # Second Order Differential Equation
  # syntax: desolve(equation, unknown_function, boundary_conds
  # in this case: y_0, x_0 and dy/dx(0)
  sage: desolve(diff(y,x,x) + x*diff(y,x) + y == 0, y, [0,0,1])
#+END_SRC

** Analysis
